/* * TINS 2010 - The source god * Authors: Victor Williams Stafusa da Silva *          André Luiz Pereira Álvares */#include "game.h"#define TILE_W 40#define TILE_H 40class FiltroMataPalito : public virtual Filtro {  public:    FiltroMataPalito() {    }    bool aceita(Personagem* p) {        return p->amigo() && p->get_hp() > 0;    }};// Classe MonstroVerde.#define MONSTRO_VERDE_LARGURA 40#define MONSTRO_VERDE_ALTURA 40MonstroVerde::MonstroVerde(int x, int y, Jogo *jogo) :        Monstro(TIPO_MONSTRO_VERDE, x, y, MONSTRO_VERDE_LARGURA, MONSTRO_VERDE_ALTURA, 2, 30, jogo) {    this->sprite_offset_y = -8;    this->sprite_offset_x = -1;    this->hp_max = this->hp = 100;    this->forca = 8;    this->tempo_ataque = 8;    this->tempo_apanha = 8;    this->tempo_morre = 10;}MonstroVerde::~MonstroVerde() {}BITMAP *MonstroVerde::sprite_quadro(int q, bool transparente) {    int flag = (estado == ATACANDO ? MONSTRO_VERDE_ATACA :                estado == APANHANDO || estado == MORTO ? MONSTRO_VERDE_APANHA :                q ? MONSTRO_VERDE_A : MONSTRO_VERDE_B);    return jogo->sprite(flag + (transparente ? TRANSPARENTE : 0));}PathFinder *MonstroVerde::destinos() {    return new PerseguePalitoPathFinder(TILE_W, TILE_H, new ViolenciaContraPalitos(), jogo);}void MonstroVerde::chegou() {    FiltroMataPalito fp;    atacar(&fp);}void MonstroVerde::morreu() {    jogo->play_som(SOUND_AHHH, 500);}// Classe MonstroVermelho.#define MONSTRO_VERMELHO_LARGURA 20#define MONSTRO_VERMELHO_ALTURA 33MonstroVermelho::MonstroVermelho(int x, int y, Jogo *jogo) :        Monstro(TIPO_MONSTRO_VERMELHO, x, y, MONSTRO_VERMELHO_LARGURA, MONSTRO_VERMELHO_ALTURA, 2, 5, jogo) {    this->sprite_offset_x = -1;    this->sprite_offset_y = -9;    this->hp_max = this->hp = 25;    this->forca = 3;    this->tempo_ataque = 3;    this->tempo_apanha = 3;    this->tempo_morre = 10;}MonstroVermelho::~MonstroVermelho() {}BITMAP *MonstroVermelho::sprite_quadro(int q, bool transparente) {    int flag = (estado == ATACANDO ? MONSTRO_VERMELHO_ATACA :                estado == APANHANDO || estado == MORTO ? MONSTRO_VERMELHO_APANHA :                q ? MONSTRO_VERMELHO_A : MONSTRO_VERMELHO_B);    return jogo->sprite(flag + (transparente ? TRANSPARENTE : 0));}PathFinder *MonstroVermelho::destinos() {    return new PerseguePalitoPathFinder(TILE_W, TILE_H, new ViolenciaContraPalitos(), jogo);}void MonstroVermelho::chegou() {    FiltroMataPalito fp;    atacar(&fp);}// Classe Bug.#define BUG_LARGURA 29#define BUG_ALTURA 29Bug::Bug(int x, int y, Jogo *jogo) :        Monstro(TIPO_BUG, x, y, BUG_LARGURA, BUG_ALTURA, 2, 15, jogo) {    this->sprite_offset_x = -4;    this->sprite_offset_y = -4;    this->hp_max = this->hp = 10;    this->forca = 1;    this->tempo_ataque = 5;    this->tempo_apanha = 1;    this->tempo_morre = 10;}Bug::~Bug() {}PathFinder *Bug::destinos() {    return new ComeLetraPerseguePalitoPathFinder(TILE_W, TILE_H, new ViolenciaContraPalitos(), jogo);}BITMAP *Bug::sprite_quadro(int q, bool transparente) {    int flag = (estado == ATACANDO ? BUG_ATACA :                estado == APANHANDO || estado == MORTO ? BUG_APANHA :                q ? BUG_A : BUG_B);    int flags = flag + (transparente ? TRANSPARENTE : 0);    if (direcao_x < 0) {        flags += ROTATE_LEFT;    } else if (direcao_x > 0) {        flags += ROTATE_RIGHT;    } else if (direcao_y > 0) {        flags += ROTATE_180;    }    return jogo->sprite(flags);}void Bug::atacar_texto() {    CharacterIterator *cit = jogo->iterate_source();    while (cit != NULL && cit->has_next()) {        Character *c = cit->next();        if (!c->is_valid() || !c->is_visible()) continue;        int x1 = c->get_x() * 8 + 35;        int y1 = c->get_y() * 20 + 30;        bool colide_x = colide(x - 20, x + larg + 20, x1, x1 + 8);        bool colide_y = colide(y - 20, y + alt + 20, y1, y1 + 8);        if (colide_x && colide_y) {            c->set_visible(false);            jogo->dec_char_count();            break;        }    }    delete cit;}void Bug::chegou() {    FiltroMataPalito fp;    atacar(&fp);    atacar_texto();}