/* * TINS 2010 - The source god * Authors: Victor Williams Stafusa da Silva *          André Luiz Pereira Álvares */#include "game.h"// Classe FiltroSolidoclass FiltroSolido : public virtual Filtro {  public:    FiltroSolido() {}    bool aceita(Personagem* p) {        return p->solido();    }};// Classe PersonagemPersonagem::Personagem(int tipo, int x, int y, int larg, int alt, int num_quadros, int duracao, Jogo *jogo) {    this->tipo = tipo;    this->x = x;    this->y = y;    this->larg = larg;    this->alt = alt;    this->sprite_offset_x = 0;    this->sprite_offset_y = 0;    this->hp = 0;    this->hp_max = 0;    this->jogo = jogo;    this->quero_x = -1;    this->quero_y = -1;    this->duracao = duracao;    this->num_quadros = num_quadros;    this->quadro = rand() % (duracao * num_quadros);    this->direcao_x = 0;    this->direcao_y = 0;    this->estado = ANDANDO;    this->tempo_ataque = 0;    this->tempo_apanha = 0;    this->tempo_morre = 0;    this->parada = 0;    this->na_mao = false;    this->selecionado = false;}Personagem::~Personagem() {}// Setters e getters.int Personagem::get_tipo() {    return tipo;}void Personagem::posicionar(int x, int y) {    this->x = x;    this->y = y;}int Personagem::get_x() {    return this->x;}int Personagem::get_y() {    return this->y;}int Personagem::get_altura() {    return this->alt;}int Personagem::get_largura() {    return this->larg;}int Personagem::get_hp() {    return hp;}bool Personagem::inimigo() {    return false;}bool Personagem::amigo() {    return false;}bool Personagem::solido() {    return false;}void Personagem::set_na_mao(bool na_mao) {    this->na_mao = na_mao;}bool Personagem::is_na_mao() {    return na_mao;}void Personagem::unselect() {    selecionado = false;}// Desenho:void Personagem::render(BITMAP *buffer, bool transparente) {    BITMAP *sprite = sprite_quadro(this->quadro / duracao, transparente);    //if (!transparente) rect(buffer, x, y, x + larg - 1, y + alt - 1, VERMELHO);    if (selecionado && !transparente) {        ellipse(buffer, this->x + this->sprite_offset_x + (sprite->w / 2),                        this->y + this->sprite_offset_y + 2,                        (sprite->w / 2), 2, AZUL);    }    draw_sprite(buffer, sprite, this->x + this->sprite_offset_x, this->y + this->sprite_offset_y);    if (transparente && hp != 0) {        BITMAP *barra_vazia = jogo->sprite(BARRA_VAZIA);        int tx = this->x + this->sprite_offset_x - ((barra_vazia->w - sprite->w) / 2);        int ty = this->y + this->sprite_offset_y - 15;        masked_blit(jogo->sprite(BARRA_VAZIA), buffer, 0, 0, tx, ty, barra_vazia->w, barra_vazia->h);        int cor_barra = (hp > 2 * hp_max / 3) ? BARRA_VERDE : (hp > hp_max / 3) ? BARRA_AMARELA : BARRA_VERMELHA;        BITMAP *barra_cheia = jogo->sprite(cor_barra);        masked_blit(barra_cheia, buffer, 0, 0, tx, ty, 5 + (40 * hp / hp_max), barra_cheia->h);    }}void Personagem::proximo_quadro() {    this->quadro++;    if (this->quadro >= (duracao * num_quadros)) this->quadro = 0;}bool Personagem::aceita_clique(int x, int y, bool selecionar) {    return false;}// Ações:void Personagem::agir() {    switch (estado) {        case ANDANDO: andando(); break;        case ATACANDO: atacando(); break;        case APANHANDO: apanhando(); break;        case MORTO: morrendo(); break;    }}// Ação ANDAR:void Personagem::andando() {}bool Personagem::mover(int delta_x, int delta_y) {   bool andou = false;   direcao_x = sinal(delta_x);   direcao_y = sinal(delta_y);   while (delta_x != 0 || delta_y != 0) {       andou |= anda_pixel(sinal(delta_x), sinal(delta_y));       delta_x -= sinal(delta_x);       delta_y -= sinal(delta_y);   }   return andou;}#define CHECK_MOVE_OK move_ok = \        ((delta_x != 0 || delta_y != 0) && \         x + delta_x >= 0 && \         x + delta_x + larg <= SCREEN_W && \         y + delta_y >= 0 && \         y + delta_y + alt <= SCREEN_H); \        if (move_ok) { \            jogo->personagens_na_area(x + delta_x, y + delta_y, larg, alt, &blocks, &filtro); \            move_ok = blocks.empty(); \            blocks.clear(); \        }bool Personagem::anda_pixel(int delta_x, int delta_y) {    if (delta_x == 0 && delta_y == 0) return false;    //int mx = delta_x;    int my = delta_y;    FiltroSolido filtro;    std::list<Personagem *> blocks;    bool move_ok;    CHECK_MOVE_OK;    if (!move_ok) {        if (delta_x == 0 || delta_y == 0) return false;        delta_y = 0;        CHECK_MOVE_OK                if (!move_ok) {            delta_x = 0;            delta_y = my;            CHECK_MOVE_OK            if (!move_ok) return false;        }    }    this->y += delta_y;    this->x += delta_x;    return true;}// Ação ATACAR:void Personagem::atacando() {    if (this->parada == 0) {        this->estado = ANDANDO;    } else {        this->parada--;    }}bool Personagem::atacar(Filtro *f) {    this->estado = ATACANDO;    this->parada = this->tempo_ataque;    std::list<Personagem *> achou;    jogo->personagens_na_area(x - 5, y - 5, larg + 5, alt + 5, &achou, f);    std::list<Personagem *>::iterator it;    for (it = achou.begin(); it != achou.end(); it++) {        Personagem *p = *it;        p->apanhar(5);    }    return !achou.empty();}// Ação APANHAR:void Personagem::apanhando() {    if (this->parada == 0) {        this->estado = ANDANDO;    } else {        this->parada--;    }}void Personagem::apanhar(int qtd) {    if (this->hp == 0) return;    this->hp -= qtd;    if (this->hp <= 0) {        this->hp = 0;        this->parada = this->tempo_morre;        this->estado = MORTO;        morreu();    } else {        this->estado = APANHANDO;        this->parada = this->tempo_apanha;    }}// Ação MORRER:void Personagem::morrendo() {    if (this->parada == 0) {        jogo->remove(this);    } else {        this->parada--;    }}void Personagem::morreu() {}